# CAHIER DES SPÉCIFICATIONS FONCTIONNELLES - PARTIE 2
## PLATEFORME DE GESTION SELF-STORAGE & VALET STORAGE

---

## 7. GESTION FINANCIÈRE & FACTURATION

### 7.1 Système de Facturation Automatisée

#### 7.1.1 Types de facturation

**1. Facturation récurrente (Monthly billing)**
- Génération automatique le jour configuré (ex: 1er du mois, date anniversaire)
- Prorata pour début/fin de mois
- Multiple billing cycles: monthly, quarterly, yearly
- Gestion des cycles annuels avec discount

**2. Facturation one-time**
- Setup fees
- Produits additionnels
- Late fees
- Services ponctuels

**3. Facturation mixte**
- Combinaison récurrent + one-time
- Agrégation intelligente

#### 7.1.2 Workflow de facturation

**Étapes automatisées:**

1. **Génération facture** (J-3 avant date billing)
   ```
   - Calcul montant récurrent
   - Ajout produits/services actifs
   - Application promotions
   - Calcul taxes
   - Génération numéro facture
   - Création PDF
   - Status: draft
   ```

2. **Envoi facture** (J-date billing)
   ```
   - Email notification avec PDF
   - Status: sent
   - Tentative auto-payment si configuré
   ```

3. **Tentative paiement automatique** (si auto-pay activé)
   ```
   - Charge payment method saved
   - Si succès: status → paid
   - Si échec: retry schedule (J+2, J+5)
   - Notification client
   ```

4. **Follow-up** (si non payé)
   ```
   - J+5: Reminder email
   - J+10: Second reminder
   - J+15: Final notice
   - J+20: Late fee ajouté
   - J+30: Overdue status
   - Access lock-out (si configuré)
   ```

5. **Paiement reçu**
   ```
   - Status → paid
   - Génération reçu
   - Email confirmation
   - Unlock access si était locked
   - Update accounting
   ```

#### 7.1.3 Base de données Facturation

```sql
-- Table invoices
CREATE TABLE invoices (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    rental_id BIGINT NULL, -- Si lié à une location
    valet_order_id BIGINT NULL, -- Si lié à valet
    uuid UUID UNIQUE NOT NULL,
    
    -- Numérotation
    invoice_number VARCHAR(50) UNIQUE NOT NULL, -- INV-2024-00001
    invoice_type ENUM('rental', 'valet', 'product', 'service', 'late_fee', 'other') DEFAULT 'rental',
    
    -- Dates
    issue_date DATE NOT NULL,
    due_date DATE NOT NULL,
    paid_at TIMESTAMP NULL,
    
    -- Status
    status ENUM('draft', 'sent', 'paid', 'partial', 'overdue', 'cancelled', 'refunded') DEFAULT 'draft',
    
    -- Montants
    subtotal DECIMAL(10,2) NOT NULL DEFAULT 0,
    discount_amount DECIMAL(10,2) DEFAULT 0,
    tax_rate DECIMAL(5,2) DEFAULT 0,
    tax_amount DECIMAL(10,2) DEFAULT 0,
    total_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
    amount_paid DECIMAL(10,2) DEFAULT 0,
    amount_due DECIMAL(10,2) GENERATED ALWAYS AS (total_amount - amount_paid) STORED,
    
    currency VARCHAR(3) DEFAULT 'EUR',
    
    -- Payment
    payment_method VARCHAR(50), -- 'card', 'sepa', 'transfer', 'cash'
    transaction_id VARCHAR(255), -- Stripe payment intent, etc.
    
    -- Auto-payment
    auto_pay_attempted BOOLEAN DEFAULT FALSE,
    auto_pay_attempts INT DEFAULT 0,
    auto_pay_last_attempt TIMESTAMP NULL,
    next_auto_pay_attempt TIMESTAMP NULL,
    
    -- PDF
    pdf_url VARCHAR(500),
    pdf_generated_at TIMESTAMP NULL,
    
    -- Reminders
    reminder_sent_count INT DEFAULT 0,
    last_reminder_sent_at TIMESTAMP NULL,
    
    -- Metadata
    notes TEXT,
    settings JSON,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP NULL,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (rental_id) REFERENCES rentals(id),
    FOREIGN KEY (valet_order_id) REFERENCES valet_orders(id),
    INDEX idx_status (status),
    INDEX idx_user (user_id),
    INDEX idx_due_date (due_date),
    INDEX idx_issue_date (issue_date)
);

-- Table invoice_items (lignes de facture)
CREATE TABLE invoice_items (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    invoice_id BIGINT NOT NULL,
    
    -- Description
    item_type VARCHAR(50), -- 'rental', 'product', 'service', 'late_fee'
    description VARCHAR(500) NOT NULL,
    
    -- Quantité & Prix
    quantity DECIMAL(10,2) DEFAULT 1,
    unit_price DECIMAL(10,2) NOT NULL,
    
    -- Discount
    discount_amount DECIMAL(10,2) DEFAULT 0,
    discount_percentage DECIMAL(5,2) DEFAULT 0,
    
    -- Tax
    tax_rate DECIMAL(5,2) DEFAULT 0,
    tax_amount DECIMAL(10,2) DEFAULT 0,
    
    -- Total
    subtotal DECIMAL(10,2) NOT NULL,
    total DECIMAL(10,2) NOT NULL,
    
    -- Accounting
    account_code VARCHAR(50), -- Pour export compta
    
    -- Reference
    reference_type VARCHAR(50), -- 'unit', 'product', 'valet_item'
    reference_id BIGINT,
    
    -- Metadata
    metadata JSON,
    
    sort_order INT DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (invoice_id) REFERENCES invoices(id) ON DELETE CASCADE
);

-- Table payments
CREATE TABLE payments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    invoice_id BIGINT NULL, -- Peut être NULL si paiement sans facture
    uuid UUID UNIQUE NOT NULL,
    
    -- Reference
    payment_number VARCHAR(50) UNIQUE NOT NULL, -- PAY-2024-00001
    
    -- Montant
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'EUR',
    
    -- Méthode
    payment_method ENUM('card', 'sepa', 'bank_transfer', 'cash', 'check', 'paypal', 'other') DEFAULT 'card',
    
    -- Gateway info
    gateway VARCHAR(50), -- 'stripe', 'mollie', 'paypal'
    gateway_transaction_id VARCHAR(255),
    gateway_fee DECIMAL(10,2) DEFAULT 0,
    net_amount DECIMAL(10,2) GENERATED ALWAYS AS (amount - gateway_fee) STORED,
    
    -- Card info (masked)
    card_brand VARCHAR(50),
    card_last4 VARCHAR(4),
    
    -- Status
    status ENUM('pending', 'processing', 'succeeded', 'failed', 'refunded', 'disputed') DEFAULT 'pending',
    
    -- Dates
    payment_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processed_at TIMESTAMP NULL,
    
    -- Refund
    refund_amount DECIMAL(10,2) DEFAULT 0,
    refunded_at TIMESTAMP NULL,
    refund_reason TEXT,
    
    -- Failure
    failure_code VARCHAR(100),
    failure_message TEXT,
    
    -- Receipt
    receipt_url VARCHAR(500),
    receipt_sent_at TIMESTAMP NULL,
    
    -- Metadata
    notes TEXT,
    settings JSON,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (invoice_id) REFERENCES invoices(id),
    INDEX idx_user (user_id),
    INDEX idx_status (status),
    INDEX idx_payment_date (payment_date),
    INDEX idx_gateway_transaction (gateway_transaction_id)
);

-- Table payment_allocations (allocation paiements aux factures)
CREATE TABLE payment_allocations (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    payment_id BIGINT NOT NULL,
    invoice_id BIGINT NOT NULL,
    amount DECIMAL(10,2) NOT NULL,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (payment_id) REFERENCES payments(id) ON DELETE CASCADE,
    FOREIGN KEY (invoice_id) REFERENCES invoices(id) ON DELETE CASCADE
);

-- Table refunds
CREATE TABLE refunds (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL,
    payment_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    uuid UUID UNIQUE NOT NULL,
    
    refund_number VARCHAR(50) UNIQUE NOT NULL,
    
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'EUR',
    
    reason TEXT NOT NULL,
    
    -- Gateway
    gateway VARCHAR(50),
    gateway_refund_id VARCHAR(255),
    
    status ENUM('pending', 'processing', 'succeeded', 'failed') DEFAULT 'pending',
    
    processed_by BIGINT NULL, -- Manager qui a initié le refund
    processed_at TIMESTAMP NULL,
    
    notes TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (payment_id) REFERENCES payments(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (processed_by) REFERENCES users(id)
);

-- Table late_fees (pénalités de retard)
CREATE TABLE late_fees (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL,
    invoice_id BIGINT NOT NULL,
    
    fee_amount DECIMAL(10,2) NOT NULL,
    fee_type ENUM('fixed', 'percentage') DEFAULT 'fixed',
    
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    applied_by BIGINT NULL, -- NULL si automatique
    
    notes TEXT,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (invoice_id) REFERENCES invoices(id),
    FOREIGN KEY (applied_by) REFERENCES users(id)
);

-- Table credit_notes (avoirs)
CREATE TABLE credit_notes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    invoice_id BIGINT NULL, -- Facture d'origine
    uuid UUID UNIQUE NOT NULL,
    
    credit_note_number VARCHAR(50) UNIQUE NOT NULL,
    
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(3) DEFAULT 'EUR',
    
    reason TEXT NOT NULL,
    
    status ENUM('draft', 'issued', 'applied', 'cancelled') DEFAULT 'draft',
    
    issued_at TIMESTAMP NULL,
    applied_at TIMESTAMP NULL,
    
    issued_by BIGINT NULL,
    
    pdf_url VARCHAR(500),
    
    notes TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (user_id) REFERENCES users(id),
    FOREIGN KEY (invoice_id) REFERENCES invoices(id),
    FOREIGN KEY (issued_by) REFERENCES users(id)
);
```

#### 7.1.4 Service de facturation automatique

**Laravel Job pour génération:**

```php
<?php

namespace App\Jobs;

use App\Models\Rental;
use App\Models\Invoice;
use App\Services\InvoiceService;
use Carbon\Carbon;
use Illuminate\Bus\Queueable;
use Illuminate\Queue\SerializesModels;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;

class GenerateRecurringInvoices implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function handle(InvoiceService $invoiceService)
    {
        // Trouver toutes les locations actives qui doivent être facturées
        $today = Carbon::today();
        
        $rentals = Rental::where('status', 'active')
            ->where('next_billing_date', '<=', $today)
            ->whereDoesntHave('invoices', function($query) use ($today) {
                $query->where('issue_date', $today)
                      ->where('status', '!=', 'cancelled');
            })
            ->with(['user', 'unit.unitType', 'site', 'products'])
            ->get();
        
        foreach ($rentals as $rental) {
            try {
                $invoice = $invoiceService->generateRentalInvoice($rental);
                
                // Envoyer email avec facture
                $rental->user->notify(new InvoiceGeneratedNotification($invoice));
                
                // Tenter auto-payment si activé
                if ($rental->auto_pay_enabled && $invoice->status === 'sent') {
                    dispatch(new ProcessAutoPayment($invoice));
                }
                
                // Calculer prochaine date de facturation
                $rental->next_billing_date = $this->calculateNextBillingDate($rental);
                $rental->save();
                
            } catch (\Exception $e) {
                \Log::error("Erreur génération facture rental {$rental->id}: {$e->getMessage()}");
            }
        }
    }
    
    private function calculateNextBillingDate(Rental $rental): Carbon
    {
        $current = Carbon::parse($rental->next_billing_date);
        
        switch ($rental->billing_cycle) {
            case 'monthly':
                return $current->addMonth();
            case 'quarterly':
                return $current->addMonths(3);
            case 'yearly':
                return $current->addYear();
            default:
                return $current->addMonth();
        }
    }
}
```

**InvoiceService:**

```php
<?php

namespace App\Services;

use App\Models\Rental;
use App\Models\Invoice;
use App\Models\InvoiceItem;
use Carbon\Carbon;
use Barryvdh\DomPDF\Facade\Pdf;

class InvoiceService
{
    /**
     * Generate invoice for rental
     */
    public function generateRentalInvoice(Rental $rental): Invoice
    {
        $tenant = $rental->tenant;
        $user = $rental->user;
        $unitType = $rental->unit->unitType;
        
        // Créer la facture
        $invoice = new Invoice();
        $invoice->tenant_id = $tenant->id;
        $invoice->user_id = $user->id;
        $invoice->rental_id = $rental->id;
        $invoice->uuid = \Str::uuid();
        $invoice->invoice_number = $this->generateInvoiceNumber($tenant);
        $invoice->invoice_type = 'rental';
        $invoice->issue_date = Carbon::today();
        $invoice->due_date = Carbon::today()->addDays($tenant->payment_terms_days ?? 0);
        $invoice->status = 'sent';
        $invoice->currency = $rental->site->currency ?? 'EUR';
        
        $subtotal = 0;
        $items = [];
        
        // Item: Location unité
        $rentalItem = [
            'item_type' => 'rental',
            'description' => "Location {$unitType->name} - Unité {$rental->unit->unit_number}",
            'quantity' => 1,
            'unit_price' => $rental->monthly_rate,
            'subtotal' => $rental->monthly_rate,
            'total' => $rental->monthly_rate,
            'account_code' => 'RENTAL_INCOME',
            'reference_type' => 'unit',
            'reference_id' => $rental->unit_id,
        ];
        $items[] = $rentalItem;
        $subtotal += $rental->monthly_rate;
        
        // Items: Produits récurrents
        foreach ($rental->products()->where('is_recurring', true)->get() as $rentalProduct) {
            $productItem = [
                'item_type' => 'product',
                'description' => $rentalProduct->product->name,
                'quantity' => $rentalProduct->quantity,
                'unit_price' => $rentalProduct->unit_price,
                'subtotal' => $rentalProduct->total_price,
                'total' => $rentalProduct->total_price,
                'account_code' => 'PRODUCT_INCOME',
                'reference_type' => 'product',
                'reference_id' => $rentalProduct->product_id,
            ];
            $items[] = $productItem;
            $subtotal += $rentalProduct->total_price;
        }
        
        // Application discount si applicable
        $discountAmount = 0;
        if ($rental->discount_amount > 0 && $rental->discount_months > 0) {
            $monthsPassed = Carbon::parse($rental->move_in_date)->diffInMonths(Carbon::today());
            if ($monthsPassed < $rental->discount_months) {
                $discountAmount = $rental->discount_amount;
            }
        }
        
        // Calcul taxes
        $taxRate = $rental->site->tax_rate ?? 0;
        $taxableAmount = $subtotal - $discountAmount;
        $taxAmount = $taxableAmount * ($taxRate / 100);
        
        // Total
        $total = $taxableAmount + $taxAmount;
        
        // Sauvegarder facture
        $invoice->subtotal = $subtotal;
        $invoice->discount_amount = $discountAmount;
        $invoice->tax_rate = $taxRate;
        $invoice->tax_amount = $taxAmount;
        $invoice->total_amount = $total;
        $invoice->save();
        
        // Créer les items
        foreach ($items as $itemData) {
            $invoiceItem = new InvoiceItem($itemData);
            $invoiceItem->invoice_id = $invoice->id;
            $invoiceItem->save();
        }
        
        // Générer PDF
        $this->generateInvoicePDF($invoice);
        
        return $invoice;
    }
    
    /**
     * Generate unique invoice number
     */
    private function generateInvoiceNumber($tenant): string
    {
        $year = Carbon::today()->year;
        $prefix = $tenant->invoice_prefix ?? 'INV';
        
        $lastInvoice = Invoice::where('tenant_id', $tenant->id)
            ->whereYear('created_at', $year)
            ->orderBy('id', 'desc')
            ->first();
        
        $nextNumber = $lastInvoice ? (int)substr($lastInvoice->invoice_number, -5) + 1 : 1;
        
        return sprintf("%s-%d-%05d", $prefix, $year, $nextNumber);
    }
    
    /**
     * Generate invoice PDF
     */
    public function generateInvoicePDF(Invoice $invoice): string
    {
        $invoice->load(['user', 'rental.unit.unitType', 'items']);
        
        $pdf = Pdf::loadView('invoices.pdf', [
            'invoice' => $invoice,
            'tenant' => $invoice->tenant,
            'user' => $invoice->user,
        ]);
        
        $filename = "invoice-{$invoice->invoice_number}.pdf";
        $path = "invoices/{$invoice->tenant_id}/{$filename}";
        
        // Upload to S3
        \Storage::disk('s3')->put($path, $pdf->output());
        
        $url = \Storage::disk('s3')->url($path);
        
        $invoice->pdf_url = $url;
        $invoice->pdf_generated_at = Carbon::now();
        $invoice->save();
        
        return $url;
    }
    
    /**
     * Send payment reminder
     */
    public function sendPaymentReminder(Invoice $invoice, int $reminderNumber = 1)
    {
        $invoice->user->notify(new PaymentReminderNotification($invoice, $reminderNumber));
        
        $invoice->reminder_sent_count++;
        $invoice->last_reminder_sent_at = Carbon::now();
        $invoice->save();
    }
    
    /**
     * Apply late fee
     */
    public function applyLateFee(Invoice $invoice)
    {
        $tenant = $invoice->tenant;
        $site = $invoice->rental ? $invoice->rental->site : null;
        
        $lateFeeAmount = $site->late_fee_amount ?? $tenant->default_late_fee ?? 25;
        
        $lateFee = new LateFee();
        $lateFee->tenant_id = $tenant->id;
        $lateFee->invoice_id = $invoice->id;
        $lateFee->fee_amount = $lateFeeAmount;
        $lateFee->fee_type = 'fixed';
        $lateFee->save();
        
        // Créer item sur facture
        $invoiceItem = new InvoiceItem();
        $invoiceItem->invoice_id = $invoice->id;
        $invoiceItem->item_type = 'late_fee';
        $invoiceItem->description = 'Frais de retard';
        $invoiceItem->quantity = 1;
        $invoiceItem->unit_price = $lateFeeAmount;
        $invoiceItem->subtotal = $lateFeeAmount;
        $invoiceItem->total = $lateFeeAmount;
        $invoiceItem->account_code = 'LATE_FEE_INCOME';
        $invoiceItem->save();
        
        // Recalculer totaux
        $invoice->subtotal += $lateFeeAmount;
        $invoice->total_amount += $lateFeeAmount;
        $invoice->save();
        
        // Régénérer PDF
        $this->generateInvoicePDF($invoice);
    }
}
```

### 7.2 Intégration Paiements (Stripe)

#### 7.2.1 Configuration Stripe

```php
<?php

namespace App\Services;

use Stripe\Stripe;
use Stripe\Customer;
use Stripe\PaymentIntent;
use Stripe\PaymentMethod;
use Stripe\SetupIntent;
use App\Models\Payment;
use App\Models\Invoice;
use App\Models\User;

class StripeService
{
    public function __construct()
    {
        Stripe::setApiKey(config('services.stripe.secret'));
    }
    
    /**
     * Create or retrieve Stripe customer
     */
    public function getOrCreateCustomer(User $user): string
    {
        if ($user->stripe_customer_id) {
            return $user->stripe_customer_id;
        }
        
        $customer = Customer::create([
            'email' => $user->email,
            'name' => $user->first_name . ' ' . $user->last_name,
            'phone' => $user->phone,
            'metadata' => [
                'user_id' => $user->id,
                'tenant_id' => $user->tenant_id,
            ],
        ]);
        
        $user->stripe_customer_id = $customer->id;
        $user->save();
        
        return $customer->id;
    }
    
    /**
     * Create setup intent for saving payment method
     */
    public function createSetupIntent(User $user): array
    {
        $customerId = $this->getOrCreateCustomer($user);
        
        $setupIntent = SetupIntent::create([
            'customer' => $customerId,
            'payment_method_types' => ['card', 'sepa_debit'],
        ]);
        
        return [
            'client_secret' => $setupIntent->client_secret,
            'setup_intent_id' => $setupIntent->id,
        ];
    }
    
    /**
     * Save payment method after setup intent confirmation
     */
    public function savePaymentMethod(User $user, string $paymentMethodId, bool $setAsDefault = true)
    {
        $customerId = $this->getOrCreateCustomer($user);
        
        // Attach payment method to customer
        $paymentMethod = PaymentMethod::retrieve($paymentMethodId);
        $paymentMethod->attach(['customer' => $customerId]);
        
        if ($setAsDefault) {
            Customer::update($customerId, [
                'invoice_settings' => [
                    'default_payment_method' => $paymentMethodId,
                ],
            ]);
        }
        
        // Save in database
        $userPaymentMethod = $user->paymentMethods()->create([
            'payment_type' => $paymentMethod->type === 'sepa_debit' ? 'sepa' : 'card',
            'gateway_id' => $customerId,
            'payment_method_id' => $paymentMethodId,
            'last4' => $paymentMethod->card->last4 ?? $paymentMethod->sepa_debit->last4 ?? null,
            'brand' => $paymentMethod->card->brand ?? null,
            'exp_month' => $paymentMethod->card->exp_month ?? null,
            'exp_year' => $paymentMethod->card->exp_year ?? null,
            'iban_last4' => $paymentMethod->sepa_debit->last4 ?? null,
            'bank_name' => $paymentMethod->sepa_debit->bank_code ?? null,
            'is_default' => $setAsDefault,
            'is_verified' => true,
        ]);
        
        return $userPaymentMethod;
    }
    
    /**
     * Process payment for invoice
     */
    public function processPayment(Invoice $invoice, string $paymentMethodId = null): Payment
    {
        $user = $invoice->user;
        $customerId = $this->getOrCreateCustomer($user);
        
        // Si pas de payment method fourni, utiliser le default
        if (!$paymentMethodId) {
            $paymentMethodId = $user->paymentMethods()
                ->where('is_default', true)
                ->first()
                ->payment_method_id;
        }
        
        // Créer payment intent
        $paymentIntent = PaymentIntent::create([
            'amount' => (int)($invoice->total_amount * 100), // En centimes
            'currency' => strtolower($invoice->currency),
            'customer' => $customerId,
            'payment_method' => $paymentMethodId,
            'off_session' => true,
            'confirm' => true,
            'metadata' => [
                'invoice_id' => $invoice->id,
                'invoice_number' => $invoice->invoice_number,
                'user_id' => $user->id,
                'tenant_id' => $invoice->tenant_id,
            ],
            'description' => "Facture {$invoice->invoice_number}",
        ]);
        
        // Créer payment record
        $payment = new Payment();
        $payment->tenant_id = $invoice->tenant_id;
        $payment->user_id = $user->id;
        $payment->invoice_id = $invoice->id;
        $payment->uuid = \Str::uuid();
        $payment->payment_number = $this->generatePaymentNumber($invoice->tenant);
        $payment->amount = $invoice->total_amount;
        $payment->currency = $invoice->currency;
        $payment->payment_method = 'card';
        $payment->gateway = 'stripe';
        $payment->gateway_transaction_id = $paymentIntent->id;
        $payment->gateway_fee = ($paymentIntent->application_fee_amount ?? 0) / 100;
        
        if ($paymentIntent->status === 'succeeded') {
            $payment->status = 'succeeded';
            $payment->processed_at = Carbon::now();
            
            // Marquer facture comme payée
            $invoice->status = 'paid';
            $invoice->paid_at = Carbon::now();
            $invoice->amount_paid = $invoice->total_amount;
            $invoice->payment_method = 'card';
            $invoice->transaction_id = $paymentIntent->id;
            $invoice->save();
            
        } elseif ($paymentIntent->status === 'requires_action') {
            $payment->status = 'pending';
            $payment->settings = [
                'requires_action' => true,
                'next_action' => $paymentIntent->next_action,
                'client_secret' => $paymentIntent->client_secret,
            ];
        } else {
            $payment->status = 'failed';
            $payment->failure_code = $paymentIntent->last_payment_error->code ?? 'unknown';
            $payment->failure_message = $paymentIntent->last_payment_error->message ?? 'Unknown error';
        }
        
        $payment->save();
        
        // Allocation du paiement
        if ($payment->status === 'succeeded') {
            $payment->allocations()->create([
                'invoice_id' => $invoice->id,
                'amount' => $payment->amount,
            ]);
        }
        
        return $payment;
    }
    
    /**
     * Generate payment number
     */
    private function generatePaymentNumber($tenant): string
    {
        $year = Carbon::today()->year;
        $prefix = $tenant->payment_prefix ?? 'PAY';
        
        $lastPayment = Payment::where('tenant_id', $tenant->id)
            ->whereYear('created_at', $year)
            ->orderBy('id', 'desc')
            ->first();
        
        $nextNumber = $lastPayment ? (int)substr($lastPayment->payment_number, -5) + 1 : 1;
        
        return sprintf("%s-%d-%05d", $prefix, $year, $nextNumber);
    }
}
```

---

## 8. SYSTÈME D'ANALYTICS & REPORTING

### 8.1 Dashboard Analytics

#### 8.1.1 Métriques principales (KPIs)

**Occupation:**
- Taux d'occupation global (%)
- Taux par site
- Taux par type d'unité
- Trend sur 12 mois
- Comparaison année précédente

**Revenus:**
- MRR (Monthly Recurring Revenue)
- ARR (Annual Recurring Revenue)
- Revenue per available unit (RevPAU)
- Revenue per occupied unit
- Trend revenues
- Breakdown par site/type

**Clients:**
- Total clients actifs
- Nouveaux clients (mois/année)
- Churned clients
- Customer Lifetime Value (CLV)
- Acquisition cost (CAC)
- Taux de rétention

**Opérations:**
- Move-ins planifiés
- Move-outs planifiés
- Unités en maintenance
- Paiements en retard
- Support tickets ouverts

**Valet Storage (si applicable):**
- Orders en cours
- Items en stock
- Deliveries planifiées
- Capacity utilisation warehouse

#### 8.1.2 Graphiques & Visualisations

**1. Occupation Timeline**
```javascript
// Chart.js config
{
  type: 'line',
  data: {
    labels: ['Jan', 'Feb', 'Mar', ...],
    datasets: [{
      label: 'Taux d\'occupation',
      data: [85, 87, 89, ...],
      borderColor: 'rgb(75, 192, 192)',
      tension: 0.1
    }]
  },
  options: {
    scales: {
      y: {
        beginAtZero: true,
        max: 100,
        ticks: {
          callback: function(value) {
            return value + '%';
          }
        }
      }
    }
  }
}
```

**2. Revenue Breakdown (Pie Chart)**
```
- Self Storage: 70%
- Valet Storage: 20%
- Products & Services: 7%
- Late Fees: 3%
```

**3. Unit Types Performance (Bar Chart)**
```
- 5x5: 95% occupied
- 10x10: 88% occupied
- 10x20: 76% occupied
- Climate: 92% occupied
```

**4. Customer Acquisition Funnel**
```
Website Visits → Booking Started → Documents Uploaded → Payment → Move-in
  1000           250 (25%)         180 (72%)            150 (83%)    145 (97%)
```

#### 8.1.3 Base de données Analytics

```sql
-- Table analytics_snapshots (snapshots quotidiens)
CREATE TABLE analytics_snapshots (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL,
    site_id BIGINT NULL, -- NULL pour global
    
    snapshot_date DATE NOT NULL,
    snapshot_type ENUM('daily', 'weekly', 'monthly') DEFAULT 'daily',
    
    -- Occupation
    total_units INT NOT NULL,
    occupied_units INT NOT NULL,
    available_units INT NOT NULL,
    maintenance_units INT NOT NULL,
    occupation_rate DECIMAL(5,2) NOT NULL, -- %
    
    -- Revenus
    mrr DECIMAL(12,2) DEFAULT 0, -- Monthly Recurring Revenue
    total_revenue DECIMAL(12,2) DEFAULT 0,
    rental_revenue DECIMAL(12,2) DEFAULT 0,
    product_revenue DECIMAL(12,2) DEFAULT 0,
    valet_revenue DECIMAL(12,2) DEFAULT 0,
    late_fee_revenue DECIMAL(12,2) DEFAULT 0,
    
    -- Clients
    total_customers INT DEFAULT 0,
    active_customers INT DEFAULT 0,
    new_customers INT DEFAULT 0, -- Sur la période
    churned_customers INT DEFAULT 0,
    
    -- Move-ins/outs
    move_ins_count INT DEFAULT 0,
    move_outs_count INT DEFAULT 0,
    
    -- Paiements
    invoices_generated INT DEFAULT 0,
    invoices_paid INT DEFAULT 0,
    invoices_overdue INT DEFAULT 0,
    payment_volume DECIMAL(12,2) DEFAULT 0,
    
    -- Metadata
    additional_metrics JSON,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (site_id) REFERENCES sites(id),
    UNIQUE KEY unique_snapshot (tenant_id, site_id, snapshot_date, snapshot_type),
    INDEX idx_snapshot_date (snapshot_date)
);

-- Table custom_reports (rapports personnalisés)
CREATE TABLE custom_reports (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL,
    
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    report_type VARCHAR(50), -- 'occupation', 'revenue', 'customer', etc.
    
    -- Configuration
    filters JSON, -- Filtres appliqués
    columns JSON, -- Colonnes à afficher
    grouping JSON, -- Groupement des données
    sorting JSON, -- Tri
    
    -- Schedule
    is_scheduled BOOLEAN DEFAULT FALSE,
    schedule_frequency ENUM('daily', 'weekly', 'monthly') NULL,
    schedule_day INT NULL, -- Jour du mois ou de la semaine
    schedule_time TIME NULL,
    
    -- Recipients
    email_recipients JSON, -- Array d'emails
    
    created_by BIGINT NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,
    last_run_at TIMESTAMP NULL,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id),
    FOREIGN KEY (created_by) REFERENCES users(id)
);
```

#### 8.1.4 Service Analytics

```php
<?php

namespace App\Services;

use App\Models\AnalyticsSnapshot;
use App\Models\Tenant;
use App\Models\Site;
use Carbon\Carbon;
use Illuminate\Support\Facades\DB;

class AnalyticsService
{
    /**
     * Generate daily snapshot for tenant
     */
    public function generateDailySnapshot(Tenant $tenant, Carbon $date = null): void
    {
        $date = $date ?? Carbon::today();
        
        // Global snapshot
        $this->createSnapshot($tenant, null, $date);
        
        // Per-site snapshots
        foreach ($tenant->sites as $site) {
            $this->createSnapshot($tenant, $site, $date);
        }
    }
    
    /**
     * Create analytics snapshot
     */
    private function createSnapshot(Tenant $tenant, ?Site $site, Carbon $date)
    {
        $query = $tenant->units();
        if ($site) {
            $query->where('site_id', $site->id);
        }
        
        // Occupation metrics
        $totalUnits = $query->count();
        $occupiedUnits = $query->where('status', 'occupied')->count();
        $availableUnits = $query->where('status', 'available')->count();
        $maintenanceUnits = $query->where('status', 'maintenance')->count();
        
        $occupationRate = $totalUnits > 0 ? ($occupiedUnits / $totalUnits) * 100 : 0;
        
        // Revenue metrics
        $rentalQuery = $tenant->rentals()->where('status', 'active');
        if ($site) {
            $rentalQuery->where('site_id', $site->id);
        }
        $mrr = $rentalQuery->sum('monthly_rate');
        
        $invoiceQuery = $tenant->invoices()
            ->whereDate('issue_date', $date)
            ->where('status', '!=', 'cancelled');
        if ($site) {
            $invoiceQuery->whereHas('rental', function($q) use ($site) {
                $q->where('site_id', $site->id);
            });
        }
        
        $totalRevenue = $invoiceQuery->sum('total_amount');
        
        // Customer metrics
        $customerQuery = $tenant->users()->where('user_type', 'customer');
        $totalCustomers = $customerQuery->count();
        $activeCustomers = $customerQuery->whereHas('rentals', function($q) {
            $q->where('status', 'active');
        })->count();
        
        $newCustomers = $customerQuery->whereDate('created_at', $date)->count();
        
        // Move-ins/outs
        $moveInsCount = $tenant->rentals()
            ->whereDate('move_in_date', $date)
            ->when($site, function($q) use ($site) {
                $q->where('site_id', $site->id);
            })
            ->count();
        
        $moveOutsCount = $tenant->rentals()
            ->whereDate('move_out_date', $date)
            ->when($site, function($q) use ($site) {
                $q->where('site_id', $site->id);
            })
            ->count();
        
        // Create or update snapshot
        AnalyticsSnapshot::updateOrCreate(
            [
                'tenant_id' => $tenant->id,
                'site_id' => $site?->id,
                'snapshot_date' => $date,
                'snapshot_type' => 'daily',
            ],
            [
                'total_units' => $totalUnits,
                'occupied_units' => $occupiedUnits,
                'available_units' => $availableUnits,
                'maintenance_units' => $maintenanceUnits,
                'occupation_rate' => round($occupationRate, 2),
                'mrr' => $mrr,
                'total_revenue' => $totalRevenue,
                'total_customers' => $totalCustomers,
                'active_customers' => $activeCustomers,
                'new_customers' => $newCustomers,
                'move_ins_count' => $moveInsCount,
                'move_outs_count' => $moveOutsCount,
            ]
        );
    }
    
    /**
     * Get occupation trend
     */
    public function getOccupationTrend(Tenant $tenant, int $months = 12): array
    {
        $startDate = Carbon::today()->subMonths($months);
        
        $snapshots = AnalyticsSnapshot::where('tenant_id', $tenant->id)
            ->whereNull('site_id') // Global only
            ->where('snapshot_date', '>=', $startDate)
            ->where('snapshot_type', 'daily')
            ->orderBy('snapshot_date')
            ->get();
        
        return [
            'labels' => $snapshots->pluck('snapshot_date')->map(function($date) {
                return Carbon::parse($date)->format('M Y');
            })->toArray(),
            'data' => $snapshots->pluck('occupation_rate')->toArray(),
        ];
    }
    
    /**
     * Get revenue breakdown
     */
    public function getRevenueBreakdown(Tenant $tenant, Carbon $startDate, Carbon $endDate): array
    {
        $invoices = $tenant->invoices()
            ->whereBetween('issue_date', [$startDate, $endDate])
            ->where('status', 'paid')
            ->with('items')
            ->get();
        
        $breakdown = [
            'rental' => 0,
            'valet' => 0,
            'products' => 0,
            'late_fees' => 0,
            'other' => 0,
        ];
        
        foreach ($invoices as $invoice) {
            foreach ($invoice->items as $item) {
                switch ($item->item_type) {
                    case 'rental':
                        $breakdown['rental'] += $item->total;
                        break;
                    case 'valet':
                        $breakdown['valet'] += $item->total;
                        break;
                    case 'product':
                        $breakdown['products'] += $item->total;
                        break;
                    case 'late_fee':
                        $breakdown['late_fees'] += $item->total;
                        break;
                    default:
                        $breakdown['other'] += $item->total;
                }
            }
        }
        
        $total = array_sum($breakdown);
        
        // Convert to percentages
        $percentages = [];
        foreach ($breakdown as $key => $value) {
            $percentages[$key] = $total > 0 ? round(($value / $total) * 100, 1) : 0;
        }
        
        return [
            'amounts' => $breakdown,
            'percentages' => $percentages,
            'total' => $total,
        ];
    }
}
```

---

## 9. INTÉGRATIONS

### 9.1 Access Control Systems

#### 9.1.1 Intégrations supportées

**1. PTI Security Systems**
- Leader industrie (40+ ans)
- Gate access codes
- Unit lock control
- Auto lock-out overdue

**2. Nokē Smart Entry (Janus)**
- Bluetooth smart locks
- Mobile app access
- Remote unlock
- Audit trail

**3. Salto KS**
- Cloud-based access
- RFID cards
- Mobile credentials
- Time-based access

**4. SecuSwitch**
- Smartphone access
- Monitoring
- Remote control

#### 9.1.2 Workflow Access Control

**Processus:**

1. **Création rental** → Génération code accès unique
2. **Payment confirmé** → Activation code dans access system
3. **Client accède** → Log dans système
4. **Invoice overdue** → Auto lock-out si configuré
5. **Payment reçu** → Reactivation automatique
6. **Move-out** → Désactivation définitive

#### 9.1.3 API Access Control (exemple PTI)

```php
<?php

namespace App\Services\AccessControl;

use App\Models\Rental;
use Illuminate\Support\Facades\Http;

class PTIAccessControlService
{
    private string $apiUrl;
    private string $apiKey;
    
    public function __construct()
    {
        $this->apiUrl = config('services.pti.api_url');
        $this->apiKey = config('services.pti.api_key');
    }
    
    /**
     * Create access code for rental
     */
    public function createAccessCode(Rental $rental): array
    {
        $response = Http::withHeaders([
            'Authorization' => 'Bearer ' . $this->apiKey,
            'Content-Type' => 'application/json',
        ])->post($this->apiUrl . '/access-codes', [
            'unit_number' => $rental->unit->unit_number,
            'customer_name' => $rental->user->first_name . ' ' . $rental->user->last_name,
            'customer_email' => $rental->user->email,
            'start_date' => $rental->move_in_date,
            'end_date' => $rental->expected_move_out_date,
            'auto_expire' => true,
            'metadata' => [
                'rental_id' => $rental->id,
                'tenant_id' => $rental->tenant_id,
            ],
        ]);
        
        if ($response->successful()) {
            $data = $response->json();
            
            $rental->access_code = $data['access_code'];
            $rental->gate_code = $data['gate_code'];
            $rental->save();
            
            return [
                'success' => true,
                'access_code' => $data['access_code'],
                'gate_code' => $data['gate_code'],
            ];
        }
        
        throw new \Exception('Failed to create access code: ' . $response->body());
    }
    
    /**
     * Activate access
     */
    public function activateAccess(Rental $rental): bool
    {
        $response = Http::withHeaders([
            'Authorization' => 'Bearer ' . $this->apiKey,
        ])->post($this->apiUrl . '/access-codes/' . $rental->access_code . '/activate');
        
        return $response->successful();
    }
    
    /**
     * Deactivate access (lock-out)
     */
    public function deactivateAccess(Rental $rental): bool
    {
        $response = Http::withHeaders([
            'Authorization' => 'Bearer ' . $this->apiKey,
        ])->post($this->apiUrl . '/access-codes/' . $rental->access_code . '/deactivate');
        
        return $response->successful();
    }
    
    /**
     * Delete access code
     */
    public function deleteAccessCode(Rental $rental): bool
    {
        $response = Http::withHeaders([
            'Authorization' => 'Bearer ' . $this->apiKey,
        ])->delete($this->apiUrl . '/access-codes/' . $rental->access_code);
        
        return $response->successful();
    }
    
    /**
     * Get access logs
     */
    public function getAccessLogs(Rental $rental, Carbon $startDate, Carbon $endDate): array
    {
        $response = Http::withHeaders([
            'Authorization' => 'Bearer ' . $this->apiKey,
        ])->get($this->apiUrl . '/access-logs', [
            'access_code' => $rental->access_code,
            'start_date' => $startDate->toIso8601String(),
            'end_date' => $endDate->toIso8601String(),
        ]);
        
        if ($response->successful()) {
            return $response->json()['logs'];
        }
        
        return [];
    }
}
```

### 9.2 Accounting Software

#### 9.2.1 Intégrations supportées

**1. Xero**
- Sync invoices
- Sync payments
- Sync customers
- Chart of accounts mapping

**2. QuickBooks Online**
- Bidirectional sync
- Multi-currency
- Tax handling

**3. Odoo**
- Full ERP integration
- Inventory management

#### 9.2.2 Xero Integration

```php
<?php

namespace App\Services\Accounting;

use App\Models\Invoice;
use App\Models\Payment;
use XeroAPI\XeroPHP\Api\AccountingApi;
use XeroAPI\XeroPHP\Models\Accounting\Invoice as XeroInvoice;
use XeroAPI\XeroPHP\Models\Accounting\LineItem;
use XeroAPI\XeroPHP\Models\Accounting\Contact;
use XeroAPI\XeroPHP\Models\Accounting\Payment as XeroPayment;

class XeroService
{
    private AccountingApi $accountingApi;
    private string $tenantId;
    
    public function __construct()
    {
        // Initialize Xero API avec OAuth2
        // ...
    }
    
    /**
     * Sync invoice to Xero
     */
    public function syncInvoice(Invoice $invoice): string
    {
        $user = $invoice->user;
        
        // Create or get contact
        $contact = new Contact();
        $contact->setName($user->first_name . ' ' . $user->last_name);
        $contact->setEmailAddress($user->email);
        
        // Create line items
        $lineItems = [];
        foreach ($invoice->items as $item) {
            $lineItem = new LineItem();
            $lineItem->setDescription($item->description);
            $lineItem->setQuantity($item->quantity);
            $lineItem->setUnitAmount($item->unit_price);
            $lineItem->setAccountCode($item->account_code ?? '4000'); // Revenue account
            $lineItem->setTaxType($item->tax_rate > 0 ? 'OUTPUT2' : 'NONE');
            $lineItem->setLineAmount($item->subtotal);
            
            $lineItems[] = $lineItem;
        }
        
        // Create invoice
        $xeroInvoice = new XeroInvoice();
        $xeroInvoice->setType(XeroInvoice::TYPE_ACCREC); // Accounts Receivable
        $xeroInvoice->setContact($contact);
        $xeroInvoice->setDate($invoice->issue_date);
        $xeroInvoice->setDueDate($invoice->due_date);
        $xeroInvoice->setInvoiceNumber($invoice->invoice_number);
        $xeroInvoice->setReference('Rental #' . ($invoice->rental?->rental_number ?? 'N/A'));
        $xeroInvoice->setLineItems($lineItems);
        $xeroInvoice->setStatus($invoice->status === 'paid' ? XeroInvoice::STATUS_AUTHORISED : XeroInvoice::STATUS_DRAFT);
        $xeroInvoice->setCurrencyCode($invoice->currency);
        
        // Send to Xero
        $result = $this->accountingApi->createInvoices($this->tenantId, [$xeroInvoice]);
        
        $xeroInvoiceId = $result->getInvoices()[0]->getInvoiceID();
        
        // Save Xero ID
        $invoice->xero_invoice_id = $xeroInvoiceId;
        $invoice->save();
        
        return $xeroInvoiceId;
    }
    
    /**
     * Sync payment to Xero
     */
    public function syncPayment(Payment $payment): string
    {
        $invoice = $payment->invoice;
        
        if (!$invoice->xero_invoice_id) {
            $this->syncInvoice($invoice);
        }
        
        $xeroPayment = new XeroPayment();
        $xeroPayment->setInvoiceID($invoice->xero_invoice_id);
        $xeroPayment->setAccountID(config('xero.bank_account_id')); // Bank account in Xero
        $xeroPayment->setAmount($payment->amount);
        $xeroPayment->setDate($payment->payment_date);
        $xeroPayment->setReference($payment->payment_number);
        
        $result = $this->accountingApi->createPayment($this->tenantId, $xeroPayment);
        
        $xeroPaymentId = $result->getPayments()[0]->getPaymentID();
        
        // Save Xero ID
        $payment->xero_payment_id = $xeroPaymentId;
        $payment->save();
        
        return $xeroPaymentId;
    }
}
```

### 9.3 Marketing & CRM

#### 9.3.1 Intégrations CRM

**1. HubSpot**
- Lead sync
- Contact management
- Email campaigns
- Pipeline tracking

**2. Salesforce**
- Enterprise CRM
- Advanced analytics
- Workflow automation

**3. Zendesk**
- Support ticketing
- Customer communication
- Knowledge base

#### 9.3.2 Email Marketing

**SendGrid / Mailgun / Amazon SES**
- Transactional emails
- Marketing campaigns
- Templates
- Analytics

#### 9.3.3 Google Analytics / Facebook Pixel

**Tracking:**
- Page views
- Booking funnel
- Conversion events
- UTM parameters
- Campaign performance

---

## 10. SÉCURITÉ & CONFORMITÉ

### 10.1 Sécurité Applicative

#### 10.1.1 Authentification

**Multi-factor Authentication (2FA):**
```php
// Utilisation de Google2FA
composer require pragmarx/google2fa-laravel

// Setup 2FA for user
$google2fa = app('pragmarx.google2fa');
$secret = $google2fa->generateSecretKey();

$user->two_factor_secret = encrypt($secret);
$user->save();

$QR_Image = $google2fa->getQRCodeInline(
    config('app.name'),
    $user->email,
    $secret
);

// Verification
$valid = $google2fa->verifyKey(
    decrypt($user->two_factor_secret),
    $request->input('one_time_password')
);
```

**SSO (Single Sign-On):**
- Azure AD integration
- Google Workspace
- SAML 2.0 support

#### 10.1.2 Autorisation

**Laravel Policies:**
```php
<?php

namespace App\Policies;

use App\Models\User;
use App\Models\Rental;

class RentalPolicy
{
    /**
     * Determine if user can view rental
     */
    public function view(User $user, Rental $rental): bool
    {
        // Admins can view all
        if ($user->hasRole('tenant_admin')) {
            return true;
        }
        
        // Managers can view rentals in their sites
        if ($user->hasRole('manager')) {
            return $user->managedSites->contains($rental->site_id);
        }
        
        // Customers can only view their own
        return $user->id === $rental->user_id;
    }
    
    /**
     * Determine if user can update rental
     */
    public function update(User $user, Rental $rental): bool
    {
        // Only admins and managers
        return $user->hasRole(['tenant_admin', 'manager']);
    }
    
    /**
     * Determine if user can delete rental
     */
    public function delete(User $user, Rental $rental): bool
    {
        // Only admins
        return $user->hasRole('tenant_admin');
    }
}
```

#### 10.1.3 Encryption

**Data at Rest:**
- Database encryption (MySQL Transparent Data Encryption)
- File storage encryption (AWS S3 server-side encryption)
- Sensitive fields encryption in Laravel:

```php
// Model with encrypted attributes
protected $casts = [
    'ssn' => 'encrypted',
    'bank_account' => 'encrypted',
    'two_factor_secret' => 'encrypted',
];
```

**Data in Transit:**
- HTTPS/TLS 1.3 obligatoire
- HSTS headers
- Certificate pinning pour mobile apps

#### 10.1.4 Rate Limiting

```php
// routes/api.php
Route::middleware('throttle:api')->group(function () {
    // 60 requests per minute
});

Route::middleware('throttle:10,1')->group(function () {
    // Login: 10 attempts per minute
    Route::post('login', [AuthController::class, 'login']);
});

// Custom rate limiter
RateLimiter::for('bookings', function (Request $request) {
    return $request->user()
        ? Limit::perMinute(20)->by($request->user()->id)
        : Limit::perMinute(5)->by($request->ip());
});
```

#### 10.1.5 Security Headers

```php
// middleware/SecurityHeaders.php
public function handle($request, Closure $next)
{
    $response = $next($request);
    
    $response->headers->set('X-Frame-Options', 'DENY');
    $response->headers->set('X-Content-Type-Options', 'nosniff');
    $response->headers->set('X-XSS-Protection', '1; mode=block');
    $response->headers->set('Referrer-Policy', 'strict-origin-when-cross-origin');
    $response->headers->set('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');
    
    $response->headers->set('Content-Security-Policy', 
        "default-src 'self'; " .
        "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://js.stripe.com; " .
        "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; " .
        "img-src 'self' data: https:; " .
        "font-src 'self' https://fonts.gstatic.com; " .
        "connect-src 'self' https://api.stripe.com;"
    );
    
    return $response;
}
```

### 10.2 Conformité RGPD

#### 10.2.1 Données personnelles

**Types de données collectées:**
- Identité (nom, prénom, date de naissance)
- Contact (email, téléphone, adresse)
- Données financières (moyens de paiement, factures)
- Documents (pièce d'identité, justificatif de domicile)
- Données de connexion (IP, logs)
- Données de localisation (pour valet storage)

**Bases légales:**
- Exécution du contrat (location storage)
- Obligation légale (facturation, KYC)
- Intérêt légitime (sécurité, prévention fraude)
- Consentement (marketing, cookies)

#### 10.2.2 Droits des utilisateurs

**Implémentation:**

```php
<?php

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use ZipArchive;

class GdprController extends Controller
{
    /**
     * Export user data (Right to data portability)
     */
    public function exportData(Request $request)
    {
        $user = $request->user();
        
        $data = [
            'profile' => [
                'first_name' => $user->first_name,
                'last_name' => $user->last_name,
                'email' => $user->email,
                'phone' => $user->phone,
                'address' => [
                    'line1' => $user->address_line1,
                    'line2' => $user->address_line2,
                    'city' => $user->city,
                    'postal_code' => $user->postal_code,
                    'country' => $user->country,
                ],
                'created_at' => $user->created_at,
            ],
            'rentals' => $user->rentals()->with('unit', 'site')->get(),
            'invoices' => $user->invoices()->get(),
            'payments' => $user->payments()->get(),
            'valet_orders' => $user->valetOrders()->with('items')->get(),
            'documents' => $user->documents()->get(),
        ];
        
        // Create JSON file
        $filename = "data_export_{$user->id}_" . now()->format('Y-m-d') . ".json";
        Storage::put("exports/{$filename}", json_encode($data, JSON_PRETTY_PRINT));
        
        // Create ZIP with documents
        $zip = new ZipArchive();
        $zipFilename = "data_export_{$user->id}_" . now()->format('Y-m-d') . ".zip";
        $zipPath = storage_path("app/exports/{$zipFilename}");
        
        if ($zip->open($zipPath, ZipArchive::CREATE) === TRUE) {
            // Add JSON
            $zip->addFile(storage_path("app/exports/{$filename}"), 'data.json');
            
            // Add all user documents
            foreach ($user->documents as $document) {
                $filePath = parse_url($document->file_url, PHP_URL_PATH);
                if (Storage::disk('s3')->exists($filePath)) {
                    $zip->addFromString(
                        "documents/" . basename($filePath),
                        Storage::disk('s3')->get($filePath)
                    );
                }
            }
            
            $zip->close();
        }
        
        // Send download link
        return response()->json([
            'success' => true,
            'message' => 'Export created successfully',
            'download_url' => route('gdpr.download', ['file' => $zipFilename]),
            'expires_at' => now()->addDays(7),
        ]);
    }
    
    /**
     * Delete user account (Right to erasure)
     */
    public function deleteAccount(Request $request)
    {
        $user = $request->user();
        
        // Check if user has active rentals
        if ($user->rentals()->where('status', 'active')->exists()) {
            return response()->json([
                'success' => false,
                'message' => 'Cannot delete account with active rentals. Please terminate all rentals first.',
            ], 400);
        }
        
        // Check for pending invoices
        if ($user->invoices()->where('status', '!=', 'paid')->exists()) {
            return response()->json([
                'success' => false,
                'message' => 'Cannot delete account with unpaid invoices.',
            ], 400);
        }
        
        // Anonymize data (GDPR-compliant deletion)
        $user->first_name = 'Deleted';
        $user->last_name = 'User';
        $user->email = 'deleted_' . $user->id . '@example.com';
        $user->phone = null;
        $user->address_line1 = null;
        $user->address_line2 = null;
        $user->city = null;
        $user->postal_code = null;
        $user->date_of_birth = null;
        $user->notes = null;
        $user->deleted_at = now();
        $user->save();
        
        // Delete documents
        foreach ($user->documents as $document) {
            Storage::disk('s3')->delete(parse_url($document->file_url, PHP_URL_PATH));
            $document->delete();
        }
        
        // Delete payment methods
        $user->paymentMethods()->delete();
        
        // Log deletion for compliance
        \Log::info("User account deleted (GDPR): {$user->id}");
        
        return response()->json([
            'success' => true,
            'message' => 'Account deleted successfully',
        ]);
    }
    
    /**
     * Update consent preferences
     */
    public function updateConsent(Request $request)
    {
        $validated = $request->validate([
            'marketing_emails' => 'nullable|boolean',
            'marketing_sms' => 'nullable|boolean',
            'analytics_tracking' => 'nullable|boolean',
        ]);
        
        $user = $request->user();
        
        $user->communication_preferences = array_merge(
            $user->communication_preferences ?? [],
            $validated
        );
        $user->save();
        
        return response()->json([
            'success' => true,
            'message' => 'Consent preferences updated',
            'preferences' => $user->communication_preferences,
        ]);
    }
}
```

#### 10.2.3 Registre des traitements

**Documentation requise:**
- Finalités du traitement
- Catégories de données
- Durée de conservation
- Mesures de sécurité
- Transferts hors UE

#### 10.2.4 DPO (Data Protection Officer)

**Responsabilités:**
- Audit conformité
- Formation équipes
- Gestion des demandes RGPD
- Notification violations
- Conseil direction

### 10.3 PCI DSS Compliance

**Exigences:**
- Pas de stockage numéros cartes complets
- Tokenization (Stripe, Mollie)
- Logs d'accès
- Encryption
- Tests sécurité réguliers

**Implémentation:**
- Utilisation Stripe pour tout le payment processing
- Jamais de données cartes dans notre DB
- Uniquement tokens et last4

---

## 11. API & WEBHOOKS

### 11.1 API REST Documentation

#### 11.1.1 Structure API

**Base URL:**
```
https://api.storageplatform.com/v1
```

**Authentication:**
```
Authorization: Bearer {api_token}
```

**Headers:**
```
Content-Type: application/json
Accept: application/json
X-Tenant-ID: {tenant_uuid}
```

#### 11.1.2 API Endpoints principaux

**Sites:**
```
GET    /sites              - Liste des sites
GET    /sites/{id}         - Détail site
POST   /sites              - Créer site
PUT    /sites/{id}         - Mettre à jour site
DELETE /sites/{id}         - Supprimer site
```

**Units:**
```
GET    /sites/{site_id}/units              - Liste unités d'un site
GET    /units/{id}                         - Détail unité
GET    /units/{id}/availability            - Disponibilité
POST   /sites/{site_id}/units              - Créer unité
PUT    /units/{id}                         - Mettre à jour
PATCH  /units/{id}/status                  - Changer statut
```

**Rentals:**
```
GET    /rentals                    - Liste locations
GET    /rentals/{id}               - Détail location
POST   /rentals                    - Créer location
PUT    /rentals/{id}               - Mettre à jour
POST   /rentals/{id}/move-in       - Confirmer move-in
POST   /rentals/{id}/notice        - Donner préavis
POST   /rentals/{id}/move-out      - Confirmer move-out
```

**Invoices:**
```
GET    /invoices                   - Liste factures
GET    /invoices/{id}              - Détail facture
GET    /invoices/{id}/pdf          - Télécharger PDF
POST   /invoices                   - Créer facture
POST   /invoices/{id}/send         - Envoyer par email
POST   /invoices/{id}/pay          - Enregistrer paiement
```

**Payments:**
```
GET    /payments                   - Liste paiements
GET    /payments/{id}              - Détail paiement
POST   /payments                   - Créer paiement
POST   /payments/{id}/refund       - Remboursement
```

**Valet Storage:**
```
GET    /valet/orders                       - Liste commandes
GET    /valet/orders/{id}                  - Détail commande
POST   /valet/orders                       - Créer commande
PUT    /valet/orders/{id}                  - Mettre à jour
POST   /valet/orders/{id}/steps            - Ajouter étape
GET    /valet/items                        - Liste items
POST   /valet/items/{id}/scan              - Scanner item
POST   /valet/items/{id}/photo             - Ajouter photo
```

### 11.2 Webhooks

#### 11.2.1 Configuration Webhooks

```sql
-- Table webhook_endpoints
CREATE TABLE webhook_endpoints (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    tenant_id BIGINT NOT NULL,
    uuid UUID UNIQUE NOT NULL,
    
    url VARCHAR(500) NOT NULL,
    secret VARCHAR(255) NOT NULL, -- Pour signature
    
    -- Events
    events JSON NOT NULL, -- Array d'événements souscrits
    
    is_active BOOLEAN DEFAULT TRUE,
    
    -- Metadata
    description VARCHAR(500),
    settings JSON,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id)
);

-- Table webhook_deliveries (logs)
CREATE TABLE webhook_deliveries (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    endpoint_id BIGINT NOT NULL,
    
    event_type VARCHAR(100) NOT NULL,
    payload JSON NOT NULL,
    
    status ENUM('pending', 'delivered', 'failed') DEFAULT 'pending',
    
    http_status INT NULL,
    response_body TEXT NULL,
    
    attempts INT DEFAULT 0,
    next_retry_at TIMESTAMP NULL,
    
    delivered_at TIMESTAMP NULL,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (endpoint_id) REFERENCES webhook_endpoints(id) ON DELETE CASCADE,
    INDEX idx_status (status),
    INDEX idx_created (created_at)
);
```

#### 11.2.2 Types d'événements

**Rentals:**
- `rental.created`
- `rental.updated`
- `rental.moved_in`
- `rental.notice_given`
- `rental.moved_out`
- `rental.cancelled`

**Invoices:**
- `invoice.created`
- `invoice.sent`
- `invoice.paid`
- `invoice.overdue`
- `invoice.refunded`

**Payments:**
- `payment.succeeded`
- `payment.failed`
- `payment.refunded`

**Units:**
- `unit.occupied`
- `unit.available`
- `unit.maintenance`

**Valet:**
- `valet_order.created`
- `valet_order.scheduled`
- `valet_order.completed`
- `valet_item.stored`
- `valet_item.delivered`

#### 11.2.3 Webhook Service

```php
<?php

namespace App\Services;

use App\Models\WebhookEndpoint;
use App\Models\WebhookDelivery;
use Illuminate\Support\Facades\Http;

class WebhookService
{
    /**
     * Dispatch webhook event
     */
    public function dispatch(string $eventType, array $payload, $tenant)
    {
        $endpoints = WebhookEndpoint::where('tenant_id', $tenant->id)
            ->where('is_active', true)
            ->whereJsonContains('events', $eventType)
            ->get();
        
        foreach ($endpoints as $endpoint) {
            $this->sendWebhook($endpoint, $eventType, $payload);
        }
    }
    
    /**
     * Send webhook to endpoint
     */
    private function sendWebhook(WebhookEndpoint $endpoint, string $eventType, array $payload)
    {
        $delivery = new WebhookDelivery();
        $delivery->endpoint_id = $endpoint->id;
        $delivery->event_type = $eventType;
        $delivery->payload = $payload;
        $delivery->status = 'pending';
        $delivery->save();
        
        // Queue job pour delivery
        dispatch(new \App\Jobs\DeliverWebhook($delivery));
    }
}

// Job pour delivery
namespace App\Jobs;

use App\Models\WebhookDelivery;
use Illuminate\Support\Facades\Http;

class DeliverWebhook implements ShouldQueue
{
    public function __construct(
        private WebhookDelivery $delivery
    ) {}
    
    public function handle()
    {
        $endpoint = $this->delivery->endpoint;
        
        // Generate signature
        $signature = hash_hmac('sha256', json_encode($this->delivery->payload), $endpoint->secret);
        
        try {
            $response = Http::timeout(30)
                ->withHeaders([
                    'Content-Type' => 'application/json',
                    'X-Webhook-Signature' => $signature,
                    'X-Webhook-Event' => $this->delivery->event_type,
                ])
                ->post($endpoint->url, $this->delivery->payload);
            
            $this->delivery->http_status = $response->status();
            $this->delivery->response_body = $response->body();
            
            if ($response->successful()) {
                $this->delivery->status = 'delivered';
                $this->delivery->delivered_at = now();
            } else {
                $this->delivery->status = 'failed';
                $this->scheduleRetry();
            }
            
        } catch (\Exception $e) {
            $this->delivery->status = 'failed';
            $this->delivery->response_body = $e->getMessage();
            $this->scheduleRetry();
        }
        
        $this->delivery->attempts++;
        $this->delivery->save();
    }
    
    private function scheduleRetry()
    {
        if ($this->delivery->attempts < 5) {
            // Exponential backoff: 1min, 5min, 30min, 2h, 12h
            $delays = [60, 300, 1800, 7200, 43200];
            $delay = $delays[$this->delivery->attempts] ?? 43200;
            
            $this->delivery->next_retry_at = now()->addSeconds($delay);
            
            dispatch(new DeliverWebhook($this->delivery))
                ->delay($delay);
        }
    }
}
```

---

## 12. ARCHITECTURE BASE DE DONNÉES COMPLÈTE

### 12.1 Indexes & Performance

```sql
-- Indexes critiques pour performance

-- Units
CREATE INDEX idx_units_status ON units(status);
CREATE INDEX idx_units_site_status ON units(site_id, status);
CREATE INDEX idx_units_type_status ON units(unit_type_id, status);

-- Rentals
CREATE INDEX idx_rentals_status ON rentals(status);
CREATE INDEX idx_rentals_user ON rentals(user_id, status);
CREATE INDEX idx_rentals_next_billing ON rentals(next_billing_date, status);
CREATE INDEX idx_rentals_dates ON rentals(move_in_date, move_out_date);

-- Invoices
CREATE INDEX idx_invoices_user_status ON invoices(user_id, status);
CREATE INDEX idx_invoices_due_date ON invoices(due_date, status);
CREATE INDEX idx_invoices_issue_date ON invoices(issue_date);

-- Payments
CREATE INDEX idx_payments_user ON payments(user_id);
CREATE INDEX idx_payments_invoice ON payments(invoice_id);
CREATE INDEX idx_payments_date_status ON payments(payment_date, status);

-- Valet Orders
CREATE INDEX idx_valet_orders_status ON valet_orders(status);
CREATE INDEX idx_valet_orders_driver ON valet_orders(driver_id, status);
CREATE INDEX idx_valet_orders_scheduled ON valet_orders(scheduled_date, scheduled_time_slot);

-- Valet Items
CREATE INDEX idx_valet_items_user ON valet_items(user_id, status);
CREATE INDEX idx_valet_items_barcode ON valet_items(barcode);
CREATE INDEX idx_valet_items_location ON valet_items(warehouse_location, status);
```

---

## 13. PLAN DE DÉPLOIEMENT & SCALABILITÉ

### 13.1 Infrastructure Cloud

**Architecture recommandée AWS:**

```
Load Balancer (ALB)
    ↓
Auto Scaling Group (Web Servers)
    - t3.medium instances
    - Min: 2, Max: 10
    - CPU-based scaling
    ↓
Redis Cluster (ElastiCache)
    - Cache
    - Sessions
    - Queues
    ↓
RDS PostgreSQL (Multi-AZ)
    - Master + Read Replicas
    - Automated backups
    ↓
S3 (File Storage)
    - Documents
    - Images
    - Backups
```

### 13.2 Monitoring & Alertes

**Outils:**
- Sentry (error tracking)
- New Relic / DataDog (APM)
- CloudWatch (infrastructure)
- StatusCake (uptime monitoring)

**Alertes critiques:**
- CPU > 80%
- Memory > 85%
- Disk > 90%
- Error rate > 1%
- API response time > 2s
- Queue depth > 1000

### 13.3 Backup Strategy

**Base de données:**
- Backups automatiques quotidiens
- Retention 30 jours
- Point-in-time recovery
- Test restore mensuel

**Files (S3):**
- Versioning activé
- Cross-region replication
- Lifecycle policies

**Disaster Recovery:**
- RTO: 4 heures
- RPO: 1 heure
- Runbook documenté

---

## CONCLUSION

Ce cahier des spécifications fonctionnelles fournit une base complète pour développer une plateforme SaaS de gestion de self-storage et valet storage similaire à Storeganise.

**Points clés:**
- Architecture multi-tenant scalable
- Modules backend complets (sites, unités, réservations, facturation, valet)
- Interfaces frontend optimisées (admin portal + customer portal)
- Système de paiement robuste avec Stripe
- Intégrations access control, accounting, CRM
- Conformité RGPD et sécurité
- API complète + webhooks
- Architecture base de données optimisée

**Technologies recommandées:**
- Backend: Laravel 11 + PostgreSQL + Redis
- Frontend: Vue.js 3 / React 18 + Tailwind CSS
- Infrastructure: AWS / DigitalOcean
- Payments: Stripe
- Email: SendGrid
- Monitoring: Sentry + New Relic

**Prochaines étapes:**
1. Review et validation spécifications
2. Estimation développement (6-12 mois)
3. Setup infrastructure
4. Sprint planning
5. Développement itératif
6. Tests QA
7. Beta testing
8. Launch

---

**Document créé le:** 22 Novembre 2025  
**Version:** 1.0  
**Contact:** Moez - Belgium/Tunisia
